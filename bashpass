#!/usr/bin/env bash
#
# bashpass Xdialog/dialog/terminal assisted password management.

# Timeout settings for Xdialog, Xmessage
# xmessage timeout is in seconds...
declare -rx XMTO="30"

# Signals to trap
declare -rx SIGNONE=0 SIGHUP=1 SIGINT=2 SIGQUIT=3 SIGKILL=9 SIGTERM=15

#link free (S)cript: (D)ir(N)ame, (B)ase(N)ame.
#shellcheck disable=SC2155
readonly SDN="$(dirname "$(realpath "${BASH_SOURCE[0]}")")" \
	 SBN="$(basename "$(realpath "${BASH_SOURCE[0]}")")"

readonly BPUSAGE="Usage: ${SBN} [sample.pgp] [Xdialog|dialog|terminal] [--debug] [--help]"

declare PGPF DB BNPGPF BNDB USRINTRFCE

# Process optional arguments
while [[ -n "${1}" ]]; do
    case "${1}" in
        *.pgp) PGPF="${1}";;
        Xdialog|dialog|terminal) readonly USRINTRFCE="${1}" ;;
        -d|--debug) set -x ;;
        -h|--help) echo -ne "${BPUSAGE}\n" >&2; exit 1 ;;
        *) echo -ne "Unknown option: ${1}\n" >&2;
	   echo -ne "${BPUSAGE}\n" >&2; exit 1 ;;
    esac
    shift
done

# Try to accommodate optional preference...
if [[ "${USRINTRFCE}" == "Xdialog" && -x "$(type -P "${USRINTRFCE}")" && -n "${DISPLAY}" ]]; then # Check for X, Xdialog
    #shellcheck disable=SC2155
    declare -r DIALOG="$(type -P "${USRINTRFCE}")" L="20" C="40"
elif [[ "${USRINTRFCE}" == "dialog" && -x "$(type -P "${USRINTRFCE}")" ]]; then # Check for dialog
    #shellcheck disable=SC2155
    declare -r DIALOG="$(type -P "${USRINTRFCE}")" L="0" C="0"
elif [[ "${USRINTRFCE}" == "terminal" ]]; then # plain ol' terminal
    unset DIALOG
else # -z USERINTRFCE etc
    # ... or pick a default available UI
    if [[ -x "$(type -P Xdialog)" && -n "${DISPLAY}" ]]; then # Check for X, Xdialog
	#shellcheck disable=SC2155
	declare -r DIALOG="$(type -P Xdialog)" L="20" C="40"
	readonly USRINTRFCE="Xdialog"
    elif [[ -x "$(type -P dialog)" ]]; then # Check for dialog
	#shellcheck disable=SC2155
	declare -r DIALOG="$(type -P dialog)" L="0" C="0"
	readonly USRINTRFCE="dialog"
    else
	unset DIALOG
	readonly USRINTRFCE="terminal"
    fi
fi

#shellcheck disable=SC1090
[[ -n "${DIALOG}" ]] && source "${SDN}/sources/dialog.src"
#shellcheck disable=SC1090
[[ -z "${DIALOG}" ]] && source "${SDN}/sources/terminal.src"

if [[ -n "${PGPF}" ]]; then
    readonly PGPF="${SDN}/databases/${PGPF}"
    readonly DB="${PGPF%%.pgp}"
    readonly BNPGPF="${PGPF/*\/}" BNDB="${DB/*\/}"
else
    readonly PGPF="${SDN}/databases/sample.pgp"
    readonly DB="${PGPF%%.pgp}"
    readonly BNPGPF="${PGPF/*\/}" BNDB="${DB/*\/}"
fi

readonly ACT="ac"

# SQLite
readonly -a DCM=( "sqlite3" "${DB}" ) \
	RCM=( "sqlite3" "-line" "${DB}" ) \
	ICM=( "sqlite3" "-csv" "${DB}" )

# Temp files
readonly TF="${SDN}/databases/.${BNDB}.${$}.TF"
readonly MUTEX="${SDN}/databases/.${BNDB}.MUTEX"

readonly -a PGPC=( "gpg" "--batch" "--yes" "--default-recipient-self" "--output" ) \
	 SHRC=( "shred" "--zero" "--remove" )

do_quit() {
    # Upon successfull encryption ONLY shred files
    #shellcheck disable=SC2068
    "${PGPC[@]}" "${PGPF}" "--encrypt" "${DB}" && "${SHRC[@]}" {"${DB}","${TF}","${MUTEX}"}
    read -rp "RET to continue ... " temp
    exit "${1:-0}"
}

display_feedback() {
    local -r msg="${*}"
    if [[ -n "$(type -P Xdialog 2> /dev/null)" && -n "${DISPLAY}" ]]; then
        Xdialog --title "Fatal:" --msgbox "${msg}" 0 0
    elif [[ -n "$(type -P notify-send 2> /dev/null)" && -n "${DISPLAY}" ]]; then
        notify-send "Fatal:" "${msg}"
    elif [[ -n "$(type -P xmessage 2> /dev/null)" && -n "${DISPLAY}" ]]; then
        xmessage -nearmouse -timeout "${XMTO}" "${msg}"
    elif [[ -n "$(type -P dialog 2> /dev/null)" ]]; then
        dialog --title "Fatal:" --msgbox "${msg}" 0 0
    else
        echo -ne "Fatal: ${msg}\n" >&2
    fi
    return 1
}

check_prereqs(){
    if [[ ! -t 1 ]]; then
        display_feedback "You'll need to run ${0/*\/} in a terminal (or tty)!"
    elif [[ "${BASH_VERSINFO[0]}" -lt "4" ]]; then
        display_feedback "You'll need bash major version no less than 4."
    elif [[ ! $(type -P sqlite3) ]]; then
        display_feedback "You need SQLite3 installed."
    elif [[ ! $(type -P gpg) ]]; then
        display_feedback "You need GNU Privacy Guard v2 (gnupg) installed."
    fi
}

# No mutex or die.
check_mutex() {
    if [[ -f "${MUTEX}" ]]; then
        display_feedback "You can only have one instance of ${SBN}. Follow the instructions from here: https://github.com/michaeltd/bashpass/"
    fi
}

# Decrypt .sqlite, setup trap and mutex or die.
check_decrypt() {
    if ! [[ "$(file -b "${PGPF}")" =~ ^PGP ]]; then
        display_feedback "${BNPGPF}, does not appear to be a valid PGP file."
        return $?
    fi
    #shellcheck disable=SC2068
    if ! "${PGPC[@]}" "${DB}" "--decrypt" "${PGPF}"; then
        display_feedback "Decryption failed. Follow the instructions from here: https://github.com/michaeltd/bashpass/"
        return $?
    else
	# We do have an decrypted $DB file so we might as well check it's validity.
        if ! [[ "$(file -b "${DB}")" =~ ^SQLite ]]; then
            display_feedback "${BNDB}, does not appear to be a valid SQLite 3.x database file."
            return $?
        fi
        touch "${MUTEX}"
        touch "${TF}"
    fi
}

# SQL or die.
check_sql() {
    if ! "${DCM[@]}" "SELECT * FROM ${ACT} ORDER BY rowid ASC;" &> /dev/null; then
        display_feedback "Need a working db to function. Follow the instructions from here: https://github.com/michaeltd/bashpass/"
    fi
}

#shellcheck disable=SC1090
source "${SDN}/sources/functions.src"

create() {
    #shellcheck disable=SC2155
    local MAXID="$(maxid)" DM EM UN PW CM

    "${FUNCNAME[0]}_${USRINTRFCE}" || return $?

    #shellcheck disable=SC1090
    source "${TF}"

    [[ -z "${PW}" ]] && PW="$(gpw "8")"

    "${DCM[@]}" "INSERT INTO ${ACT} VALUES('${DM//:/\:}', '${EM}', '${UN}', '${PW}', '${CM}');"
    "${RCM[@]}" "SELECT rowid AS id,* FROM ${ACT} WHERE id = $(( ++MAXID ));" > "${TF}"
    if [[ "${DIALOG}" =~ Xdialog$ ]]; then
        [[ $(type -P xclip 2> /dev/null) ]] && echo "${PW}" | "$(type -P xclip 2> /dev/null)" "-r"
        "${DIALOG}" "--backtitle" "${SBN}" "--title" "results" "--editbox" "${TF}" "${L}" "${C}" 2> /dev/null
    else
        "${PAGER}" "${TF}"
    fi
}

retrieve() {
    local DM RC PW
    if [[ -n "${DIALOG}" ]]; then
        "${DIALOG}" "--backtitle" "${SBN}" "--title" "domain" \
		    "--inputbox" "Enter domain to look for (empty for All): " "${L}" "${C}" 2> "${TF}"
        (( $? != DIALOG_OK )) && return
    else
        echo -ne "Enter domain to look for (empty for All): "
        read -r DM
        echo "${DM}" > "${TF}"
    fi
    DM=$(cat "${TF}")

    # Record Set
    "${RCM[@]}" "SELECT rowid AS id,* FROM ${ACT} WHERE dm LIKE '%${DM}%';" > "${TF}"

    if [[ "${DIALOG}" =~ Xdialog$ ]]; then
        if [[ -n "$(type -P xclip 2> /dev/null)" ]]; then
            # Record Count
            RC="$("${DCM[@]}" "SELECT count(rowid) FROM ${ACT} WHERE dm LIKE '%${DM}%';")"
            if (( RC == 1 )); then
                PW="$("${DCM[@]}" "SELECT pw FROM ${ACT} WHERE dm LIKE '%${DM}%';")"
                echo "${PW}"|"$(type -P xclip 2> /dev/null)" "-r"
            fi
        fi
        "${DIALOG}" "--backtitle" "${SBN}" "--title" "results" "--editbox" \
		    "${TF}" "${L}" "${C}" 2> /dev/null
    else
        "${PAGER}" "${TF}"
    fi
}

update() {
    local ID ERRLVL PW
    if [[ -n "${DIALOG}" ]]; then
        #shellcheck disable=SC2046
        "${DIALOG}" "--backtitle" "${SBN}" "--title" "update accout:" \
		    "--radiolist" "Select an id to update: " "${L}" "${C}" 5 $(brl) 2> "${TF}"
        ERRLVL=$? ID="$(cat "${TF}")"
        (( ERRLVL != DIALOG_OK )) || [[ -z "${ID}" ]] && return
    else
        echo -ne "Select an id to update (empty to cancel): "
        read -r ID
        ERRLVL=$?
        (( ERRLVL != DIALOG_OK )) || [[ -z "${ID}" ]] && return
    fi
    if [[ -n "${DIALOG}" ]]; then
        "${DIALOG}" --backtitle "${SBN}" --title "password" \
		    --inputbox "Enter a password or a password length (8-64) or empty for auto (max length): " \
		    "${L}" "${C}" 2> "${TF}"
        ERRLVL=$? PW="$(cat "${TF}")"
        (( ERRLVL != DIALOG_OK )) && return
    else
        echo -ne "Enter a password or a password length (8-64) or empty for auto (max length): "
        read -r PW
        ERRLVL=$?
        (( ERRLVL != DIALOG_OK )) && return
    fi
    [[ "${PW}" =~ ^[0-9]+$ ]] && (( PW >= 8 && PW <= 64 )) && PW="$(gpw "${PW}")"
    [[ -z "${PW}" ]] || (( ${#PW} < 8 )) && PW="$(gpw)"
    "${DCM[@]}" "UPDATE ${ACT} SET pw = '${PW}' WHERE rowid = '${ID}';"
    "${RCM[@]}" "SELECT rowid AS id,* FROM ${ACT} WHERE id = '${ID}';" > "${TF}"
    if [[ "${DIALOG}" =~ Xdialog$ ]]; then
        [[ -x "$(type -P xclip 2> /dev/null)" ]] && echo "${PW}" | "xclip" "-r"
        "${DIALOG}" --backtitle "${SBN}" --title "results" \
		    --editbox "${TF}" "${L}" "${C}" 2> /dev/null
    else
        "${PAGER}" "${TF}"
    fi
}

delete() {
    local ERRLVL ID
    if [[ -n "${DIALOG}" ]]; then
        #shellcheck disable=SC2046
        "${DIALOG}" --backtitle "${SBN}" --title "delete account:" \
		    --radiolist "Select an id to delete: " "${L}" "${C}" 5 $(brl) 2> "${TF}"
        ERRLVL=$? ID="$(cat "${TF}")"
        (( ERRLVL != DIALOG_OK )) || [[ -z "${ID}" ]] && return
    else
        echo -ne "Select an id to delete (empty to cancel): "
        read -r ID
        echo "${ID}" > "${TF}"
        [[ -z "${ID}" ]] && return
    fi
    "${DCM[@]}" "DELETE FROM ${ACT} WHERE rowid = '$(cat "${TF}")';"
    if [[ -n "${DIALOG}" ]]; then
	"${DIALOG}" --backtitle "${SBN}" --title "dialog" \
		    --msgbox "Account ID: #${ID} deleted." "${L}" "${C}"
    else
	echo -ne "Account ID: #${ID} deleted.\n"
    fi
    
}

importcsv() {
    local MAXID CSVF ERRLVL
    MAXID="$(maxid)"
    if [[ -n "${DIALOG}" ]]; then
        "${DIALOG}" --backtitle "${SBN}" --title "Enter a csv file:" \
		    --fselect "${HOME}/" "${L}" "${C}" 2> "${TF}"
        (( $? != DIALOG_OK )) && return
        CSVF="$(cat "${TF}")"
        [[ -z "${CSVF}" ]] && return
    else
        echo -ne "Enter a csv file (empty to cancel): "
        read -r CSVF
        echo "${CSVF}" > "${TF}"
        [[ -z "${CSVF}" ]] && return
    fi
    "${ICM[@]}" ".import ${CSVF} ${ACT}" 2> "${TF}"
    ERRLVL=$?
    if (( ERRLVL != 0 )); then
        if [[ -n "${DIALOG}" ]]; then
            "${DIALOG}" --backtitle "${SBN}" --title "Error" \
			--msgbox "$(cat "${TF}")" "${L}" "${C}"
        fi
        echo "Error: $(cat "${TF}")"
        return "${ERRLVL}"
    fi
    "${RCM[@]}" "SELECT rowid AS id,* FROM ${ACT} WHERE rowid > ${MAXID};" > "${TF}"
    if [[ "${DIALOG}" == "$(type -P Xdialog)" ]]; then
        "${DIALOG}" --backtitle "${SBN}" --title "results" \
		    --editbox "${TF}" "${L}" "${C}" 2> /dev/null
    else
        "${PAGER}" "${TF}"
    fi
}

exportcsv(){
    local CSVF ERRLVL
    if [[ -n "${DIALOG}" ]]; then
        "${DIALOG}" --backtitle "${SBN}" --title "Enter a file name:" \
		    --fselect "${HOME}/" "${L}" "${C}" 2> "${TF}"
        (( $? != DIALOG_OK )) && return
        CSVF=$(cat "${TF}")
        [[ -z "${CSVF}" ]] && return
    else
        echo -ne "Enter a file name (empty to cancel): "
        read -r CSVF
        echo "${CSVF}" > "${TF}"
        [[ -z "${CSVF}" ]] && return
    fi

    "${ICM[@]}" "select rowid,* from ${ACT} order by rowid ASC;" &> "${TF}"

    ERRLVL=$?
    if (( ERRLVL != 0 )); then
        if [[ -n "${DIALOG}" ]]; then
            "${DIALOG}" --backtitle "${SBN}" --title "Error" \
			--msgbox "$(cat "${TF}")" "${L}" "${C}"
        fi
        echo "Error: $(cat "${TF}")"
        return "${ERRLVL}"
    fi

    cat "${TF}" > "${CSVF}"

    if [[ -x "$(type -P xdg-open 2>/dev/null)" ]]; then
	"$(type -P xdg-open 2>/dev/null)" "${CSVF}"
    elif [[ -x "$(type -P "${VISUAL}" 2>/dev/null)"  ]]; then
	"$(type -P "${VISUAL}" 2>/dev/null)" "${CSVF}"
    elif [[ -x "$(type -P "${EDITOR}" 2>/dev/null)"  ]]; then
	"$(type -P "${EDITOR}" 2>/dev/null)" "${CSVF}"
    elif [[ -x "$(type -P "${PAGER}" 2>/dev/null)"  ]]; then
	"$(type -P "${PAGER}" 2>/dev/null)" "${CSVF}"
    else
	cat "${CSVF}"
    fi
}

usage() {
    [[ -n "${DIALOG}" ]] && "${DIALOG}" --backtitle "${SBN}" --title "Help" --msgbox "${GUI_HMSG[*]}" "${L}" "${C}" || echo -e "${TUI_HMSG[*]}"
}

bashpass() {
    local OFS="" ERRLVL="" USRINPT=""
    check_prereqs || exit $?
    check_mutex || exit $?
    check_decrypt || exit $?
    # Have password $DB, $TF and $MUTEX so from now on,
    # instead of exiting, we're do_quit and trap for propper housekeeping.
    check_sql || do_quit $?

    trap "do_quit ${SIGNONE}" "${SIGNONE}"
    trap "do_quit ${SIGHUP}" "${SIGHUP}"
    trap "do_quit ${SIGINT}" "${SIGINT}"
    trap "do_quit ${SIGQUIT}" "${SIGQUIT}"
    trap "do_quit ${SIGKILL}" "${SIGKILL}"
    trap "do_quit ${SIGTERM}" "${SIGTERM}"

    # Build menus and help messages.
    local -a TUI_OPS=( "${red}Create${reset}" "${green}Retrieve${reset}" "${blue}Update${reset}" "${cyan}Delete${reset}" "${yellow}Import CSV${reset}" "${yellow}Export CSV${reset}" "${magenta}SQLite3${reset}" "${white}Help${reset}" "${dim}Quit${reset}" )

    local -a GUI_OPS=( "Create" "Retrieve" "Update" "Delete" "Import CSV" "Export CSV" "SQLite3" "Help" "Quit" )

    local -a SDESC=( "New entry" "Find account" "Regen password" "Remove entry" "Import a file" "Export a file" "Sqlite3 session" "Help screen" "Exit" )

    local -a DESC=( "gather details for a new account." "search records by domain. (empty for all)" "regenerate an existing password." "remove an account." "prompt for csv file to import." "preview a csv file." "start an sqlite session against ${BNDB}." "show this message" "terminate this script." )

    local -a TUI_MENU=( )
    local -a TUI_HMSG=( "\n${BPUSAGE[*]}\n\n" )
    local GUI_MENU=""
    local -a GUI_HMSG=( "\n${BPUSAGE[*]}\n\n" )

    for (( x = 0; x < ${#TUI_OPS[@]}; x++ )); do
	TUI_MENU+=( "${x}:${TUI_OPS[x]}" )
	(( ( x + 1 ) % 4 == 0 )) && TUI_MENU+=( "\n" ) || TUI_MENU+=( "\t" )
        TUI_HMSG+=( "Use ${x}, for ${TUI_OPS[x]}, which will ${DESC[x]}\n" )
        GUI_MENU+="${GUI_OPS[x]}|${SDESC[x]}|${DESC[x]}|"
        GUI_HMSG+=( "Use ${GUI_OPS[x]}, to ${DESC[x]}\n" )
    done

    TUI_MENU+=( "\nChoose[0-$((${#TUI_OPS[*]}-1))]:" )
    TUI_HMSG+=( "\naccounts table format is as follows:\n$(${DCM[*]} ".schema ${ACT}")\n\n" )
    GUI_HMSG+=( "\naccounts table format is as follows:\n$(${DCM[*]} ".schema ${ACT}")\n\n" )

    while :; do
        if [[ -n "${DIALOG}" ]]; then # Xdialog, dialog menu
	    #shellcheck disable=SC2141
            OFS="${IFS}" IFS=$'\|'
            #shellcheck disable=SC2086
            "${DIALOG}" "--backtitle" "${SBN}" "--title" "dialog" "--item-help" \
			"--cancel-label" "Quit" "--menu" "Menu:" "${L}" "${C}" \
			${#GUI_OPS[*]} ${GUI_MENU} 2> "${TF}"
            ERRLVL=$?
            IFS="${OFS}"
        else # Just terminal menu.
            echo -ne " ${TUI_MENU[*]}"
            read -r USRINPT
            ERRLVL=$?
            echo "${USRINPT}" > "${TF}"
        fi
        case "${ERRLVL}" in
            "0"|"${DIALOG_OK}")
                case "$(cat "${TF}")" in
                    "${GUI_OPS[0]}"|"0") create ;;
                    "${GUI_OPS[1]}"|"1") retrieve ;;
                    "${GUI_OPS[2]}"|"2") update ;;
                    "${GUI_OPS[3]}"|"3") delete ;;
                    "${GUI_OPS[4]}"|"4") importcsv ;;
                    "${GUI_OPS[5]}"|"5") exportcsv ;;
                    "${GUI_OPS[6]}"|"6") "${RCM[@]}" ;;
                    "${GUI_OPS[7]}"|"7") usage ;;
                    "${GUI_OPS[8]}"|"8") exit ;;
                    *) echo -ne "Invalid responce: ${USRINPT}. Choose from 0 to $((${#TUI_OPS[*]}-1))\n" >&2;;
                esac ;;
            "1"|"${DIALOG_CANCEL}") exit ;;
            [2-4]|"${DIALOG_HELP}"|"${DIALOG_EXTRA}"|"${DIALOG_ITEM_HELP}") usage ;;
            "255"|"${DIALOG_ESC}") exit ;;
        esac
    done
}

[[ "${BASH_SOURCE[0]}" == "${0}" ]] && bashpass "${@}"
